import java.math.BigInteger;

public class FibIterative {
    public static BigInteger fib(int n) {
        BigInteger a = BigInteger.ZERO;
        BigInteger b = BigInteger.ONE;
        for (int i = 0; i < n; i++) {   // n шагов
            BigInteger tmp = a.add(b);
            a = b;
            b = tmp;
        }
        return a;                       // после n шагов a == F(n)
    }

    public static void main(String[] args) {
        int n = 100;
        System.out.println("F(" + n + ") = " + fib(n)); // 354224848179261915075
    }
}

Быстрее? Алгоритм «fast-doubling»

За O(log⁡n)O(logn) умножений:

import java.math.BigInteger;

public class FibFastDoubling {
    private static BigInteger[] fibPair(int n) {
        if (n == 0) return new BigInteger[] {BigInteger.ZERO, BigInteger.ONE};

        BigInteger[] p = fibPair(n / 2);
        BigInteger a = p[0];           // F(k)
        BigInteger b = p[1];           // F(k+1)

        // вычисляем F(2k) и F(2k+1)
        BigInteger c = a.multiply(b.shiftLeft(1).subtract(a)); // F(2k)
        BigInteger d = a.pow(2).add(b.pow(2));                 // F(2k+1)

        if (n % 2 == 0)
            return new BigInteger[] {c, d};
        else
            return new BigInteger[] {d, c.add(d)};
    }

    public static BigInteger fib(int n) { return fibPair(n)[0]; }

    public static void main(String[] args) {
        System.out.println(fib(100));
    }
}

Полезные факты
n-й элемент	Кол-во цифр	Примерное время (iter.)*
100	21	< 1 мс
1 000	209	~0.1 мс
10 000	2 090	~1 мс

*-на современной JVM; fast-doubling почти не зависит от n.

Так что для «100-го вычисления» ряда Фибоначчи вы получите именно
354 224 848 179 261 915 075.
Вы сказали:
поясните алгоритм быстрее
ChatGPT сказал:

Конечно! Алгоритм fast doubling (быстрое удвоение) — это очень эффективный способ вычисления чисел Фибоначчи за O(log n) вместо обычных O(n). Давайте разберем его по шагам:
🔍 Идея алгоритма

Он основан на следующих математических формулах, которые позволяют вычислить F(2k)F(2k) и F(2k+1)F(2k+1) через F(k)F(k) и F(k+1)F(k+1):
F(2k)=F(k)⋅[2⋅F(k+1)−F(k)]
F(2k)=F(k)⋅[2⋅F(k+1)−F(k)]
F(2k+1)=F(k)2+F(k+1)2
F(2k+1)=F(k)2+F(k+1)2
🔁 Рекурсивный подход (с кэшированием внутри стека)

Вместо того чтобы идти от нуля до n как в обычном цикле, мы:

    Делаем деление n на 2 (рекурсивно).

    Из предыдущих значений F(k)F(k) и F(k+1)F(k+1) получаем F(2k)F(2k), F(2k+1)F(2k+1).

    Возвращаем нужную пару значений.

💡 Пример на руках

Допустим, ты хочешь найти F(6):

    Сначала делим 6 / 2 = 3, идем вглубь — нужно найти F(3)F(3) и F(4)F(4)

    Чтобы найти F(3)F(3), делим 3 / 2 = 1, идем дальше: ищем F(1)F(1) и F(2)F(2)

    А F(1)=1F(1)=1, F(2)=1F(2)=1

    С этого момента начинаем собирать вверх:

        из F(1)F(1) и F(2)F(2) получаем F(2)=1F(2)=1, F(3)=2F(3)=2

        из F(3)F(3) и F(4)F(4) получаем F(6)=8F(6)=8

🔧 Код ещё раз с пояснениями

// Возвращает массив [F(n), F(n+1)]
private static BigInteger[] fibPair(int n) {
    if (n == 0) return new BigInteger[] {BigInteger.ZERO, BigInteger.ONE};

    BigInteger[] p = fibPair(n / 2);
    BigInteger a = p[0]; // F(k)
    BigInteger b = p[1]; // F(k+1)

    // Вычисление F(2k) и F(2k+1)
    BigInteger c = a.multiply(b.shiftLeft(1).subtract(a)); // c = F(2k)
    BigInteger d = a.pow(2).add(b.pow(2));                 // d = F(2k+1)

    // Возвращаем нужную пару
    if (n % 2 == 0)
        return new BigInteger[] {c, d};        // если n четное
    else
        return new BigInteger[] {d, c.add(d)}; // если нечетное
}

// Используем первую часть пары: F(n)
public static BigInteger fib(int n) {
    return fibPair(n)[0];
}

📈 Почему быстрее?

    Обычный алгоритм считает каждое предыдущее число, и у него линейное время.

    Здесь мы вдвое сокращаем n при каждом шаге → глубина стека = log₂(n)

    Вызывается всего около log₂(n) рекурсий, и каждая выполняет только несколько умножений/сложений.

✅ Вывод

Алгоритм fast doubling:

    Работает за O(log n) по времени.

    Отлично подходит для очень больших n (например, 1 000 000 и больше).

    Не требует хранения всего ряда.

    Использует только математику и рекурсию.